function backprojection()

% compute the image limitation based on data collected
data = getData();
c=3e8;
Wr   = c / (2*(data.deltaF*1e9))
Waz  = ((c / (data.FK*1e9)) / (2*data.deltaAz))
delta_r = c / (2*(data.K-1)*data.deltaF*1e9)
delta_Az = data.lambdac / (2*(data.Np-1)*data.deltaAz)

% form image based on image limitations
[data.x_mat,data.y_mat,data.z_mat] = meshgrid(-5:0.02:5,-5:0.02:5,0);


img = backproject_data(data);


end 
function img = backproject_data(data)
    c = 2.99792458e8;
    data.K = size(data.phdata,1);
    data.Np = size(data.phdata,2);
    data.AntAz = unwrap(atan2(data.AntY,data.AntX));
    data.deltaAz = abs(mean(diff(data.AntAz)));
    
    % total azimuth angle of the aperture
    data.totalAz = max(data.AntAz) - min(data.AntAz);
    data.maxWr = c/(2*data.deltaF);
    data.maxWx = c/(2*data.deltaAz*mean(data.minF));
    
    % determine resolution of the image
    data.dr = c/(2*data.deltaF*data.K);
    data.dx = c/(2*data.totalAz*mean(data.minF));
    
    % display maximum scene size and resolution
    fprintf('Maximum Scene Size: %.2f m range, %.2f m cross-range\n', data.maxWr, data.maxWx);
    fprintf('Resolution: %.2f m range, %.2f m cross-range\n', data.dr, data.dx);
    
    % calculate the range to every bin in range profile (m)
    data.r_vec = linspace(-data.Nfft/2,data.Nfft/2-1,data.Nfft)*data.maxWr/data.Nfft;
    
    % initialize image with all zero values
    data.im_final = zeros(size(data.x_mat));
    
    % set up a vector to keep execution times for every pulse
    t = zeros(1,data.Np);
    
    % loop through every pulse
    for ii = 1:data.Np
        
        % Display status of the imaging process
        if (ii>1)
            t_sofar = sum(t(1:ii-1));
            t_est = (t_sofar*data.Np/(ii-1) - t_sofar)/60;
            fprintf('Pulse %d of %d, %.02f minutes remaining\n',ii,data.Np,t_est);
        else 
            fprintf('Pulse %d of %d\n',ii,data.Np);
        end 
        tic;
        
        % Form range profile with zero padding added
        rc = fftshift(ifft(data.phdata(:,ii),data.Nfft));
        % compute differential range for each pixel in the image (m)
        dR = sqrt((data.AntX(ii) - data.x_mat).^2 + ...
            (data.AntY(ii) - data.y_mat).^2 + ...
            (data.AntZ(ii) - data.z_mat).^2) - data.RO(ii);
        
        % Calculate the phase correction for image
        phCorr = exp(1i*4*pi*data.minF(ii)/c*dR);
        
        % Determine which pixels fall within the range swath
        I = find(and(dR > min(data.r_vec), dR < max(data.r_vec)));
        
        % Update the image using linear interpolation
        data.im_final(I) = data.im_final(I) + interp1(data.r_vec,rc,dR(I),'linear') .* phCorr(I);
        
        % Determine the execution time for this pulse
        t(ii) = toc;
    end
    
    img = data.im_final;
    
   
    
end

function data = getData()
    load('backhoe_el000_az350to100.mat');
    data = struct;
    data.deltaF = FGHz(2) - FGHz(1); 
    data.minF = repmat(FGHz(1),[size(HH,1),1]);
    
    
    
    % useful convenience computations
    data.deltaAz = deg2rad( AZ(2) - AZ(1) ); % radians
    data.FK = FGHz(end); 
    data.K = length(FGHz);
    data.Fc = FGHz(data.K/2)*1e9;
    data.lambdac = 3e8 / data.Fc;
    data.Np = length(AZ);
    
    
    %arbitrary range to scene center (everything is mocomp to scene center so
%is relative to the angles anyway)
rc = 10000;
data.AntX = sin(deg2rad(AZ))*rc;
data.AntY = cos(deg2rad(AZ))*rc;
data.AntZ = zeros(size(AZ));
data.RO = sqrt(data.AntX.^2 + data.AntY.^2);
data.phdata = HH;
    
end